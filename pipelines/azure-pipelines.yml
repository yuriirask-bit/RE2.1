# RE2 Compliance Platform — CI/CD Pipeline
# Builds, tests, and deploys to Dev (auto), UAT (manual gate), Prod (manual gate).
#
# Prerequisites (manual setup in Azure DevOps):
#   Service Connections: RE2-Dev-ServiceConnection, RE2-UAT-ServiceConnection, RE2-Prod-ServiceConnection
#   Variable Groups:     re2-dev-secrets, re2-uat-secrets, re2-prod-secrets
#   Environments:        re2-dev (no gate), re2-uat (1 approver), re2-prod (2 approvers)

trigger:
  branches:
    include:
      - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  dotnetVersion: '8.0.x'
  solution: 'RE2.sln'
  apiProject: 'src/RE2.ComplianceApi/RE2.ComplianceApi.csproj'
  webProject: 'src/RE2.ComplianceWeb/RE2.ComplianceWeb.csproj'
  functionsProject: 'src/RE2.ComplianceFunctions/RE2.ComplianceFunctions.csproj'

# ──────────────────────────────────────────────────────────────────────────────
# Stage 1: Build + Test
# ──────────────────────────────────────────────────────────────────────────────
stages:
- stage: Build
  displayName: 'Build & Test'
  jobs:
  - job: BuildAndTest
    displayName: 'Restore, Build, Test, Publish'
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET 8 SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetVersion)'

    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet packages'
      inputs:
        command: 'restore'
        projects: '$(solution)'

    - task: DotNetCoreCLI@2
      displayName: 'Build solution'
      inputs:
        command: 'build'
        projects: '$(solution)'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: DotNetCoreCLI@2
      displayName: 'Run tests'
      inputs:
        command: 'test'
        projects: 'tests/**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger trx --results-directory $(Agent.TempDirectory)/TestResults'

    - task: PublishTestResults@2
      displayName: 'Publish test results'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '$(Agent.TempDirectory)/TestResults/**/*.trx'
        mergeTestResults: true

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish code coverage'
      condition: succeededOrFailed()
      inputs:
        summaryFileLocation: '$(Agent.TempDirectory)/TestResults/**/coverage.cobertura.xml'

    # Publish API artifact
    - task: DotNetCoreCLI@2
      displayName: 'Publish API'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: '$(apiProject)'
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/api'
        zipAfterPublish: true

    # Publish Web artifact
    - task: DotNetCoreCLI@2
      displayName: 'Publish Web'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: '$(webProject)'
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/web'
        zipAfterPublish: true

    # Publish Functions artifact
    - task: DotNetCoreCLI@2
      displayName: 'Publish Functions'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: '$(functionsProject)'
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/functions'
        zipAfterPublish: true

    # Copy Bicep templates as artifact
    - task: CopyFiles@2
      displayName: 'Copy Bicep templates'
      inputs:
        sourceFolder: 'infra/bicep'
        contents: '**'
        targetFolder: '$(Build.ArtifactStagingDirectory)/infra'

    - publish: $(Build.ArtifactStagingDirectory)
      artifact: 'drop'
      displayName: 'Publish pipeline artifacts'

# ──────────────────────────────────────────────────────────────────────────────
# Stage 2: Deploy Dev (auto on main merge)
# ──────────────────────────────────────────────────────────────────────────────
- stage: DeployDev
  displayName: 'Deploy to Dev'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
  - group: re2-dev-secrets
  jobs:
  - deployment: DeployDevInfra
    displayName: 'Deploy infrastructure'
    environment: 're2-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Create resource group'
            inputs:
              azureSubscription: 'RE2-Dev-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az group create \
                  --name rg-re2-dev \
                  --location westeurope \
                  --tags environment=dev application=re2-compliance

          - task: AzureCLI@2
            displayName: 'Deploy Bicep templates'
            inputs:
              azureSubscription: 'RE2-Dev-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az deployment group create \
                  --resource-group rg-re2-dev \
                  --template-file $(Pipeline.Workspace)/drop/infra/main.bicep \
                  --parameters $(Pipeline.Workspace)/drop/infra/dev.bicepparam \
                  --parameters azureAdTenantId=$(AzureAdTenantId) \
                               azureAdClientId=$(AzureAdClientId) \
                  --verbose

  - deployment: DeployDevApps
    displayName: 'Deploy applications'
    dependsOn: DeployDevInfra
    environment: 're2-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureWebApp@1
            displayName: 'Deploy API'
            inputs:
              azureSubscription: 'RE2-Dev-ServiceConnection'
              appType: 'webApp'
              appName: 'app-re2-api-dev'
              package: '$(Pipeline.Workspace)/drop/api/**/*.zip'

          - task: AzureWebApp@1
            displayName: 'Deploy Web'
            inputs:
              azureSubscription: 'RE2-Dev-ServiceConnection'
              appType: 'webApp'
              appName: 'app-re2-web-dev'
              package: '$(Pipeline.Workspace)/drop/web/**/*.zip'

          - task: AzureFunctionApp@2
            displayName: 'Deploy Functions'
            inputs:
              azureSubscription: 'RE2-Dev-ServiceConnection'
              appType: 'functionApp'
              appName: 'func-re2-compliance-dev'
              package: '$(Pipeline.Workspace)/drop/functions/**/*.zip'

          # Smoke test: verify API is responding
          - task: AzureCLI@2
            displayName: 'Smoke test — API health'
            inputs:
              azureSubscription: 'RE2-Dev-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                API_URL="https://app-re2-api-dev.azurewebsites.net/health"
                echo "Testing $API_URL"
                for i in {1..6}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL" --max-time 10)
                  if [ "$STATUS" = "200" ]; then
                    echo "Health check passed (HTTP 200)"
                    exit 0
                  fi
                  echo "Attempt $i: HTTP $STATUS — retrying in 10s..."
                  sleep 10
                done
                echo "Health check FAILED after 6 attempts"
                exit 1

          - task: AzureCLI@2
            displayName: 'Smoke test — Web health'
            inputs:
              azureSubscription: 'RE2-Dev-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                WEB_URL="https://app-re2-web-dev.azurewebsites.net/health"
                echo "Testing $WEB_URL"
                for i in {1..6}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$WEB_URL" --max-time 10)
                  if [ "$STATUS" = "200" ]; then
                    echo "Health check passed (HTTP 200)"
                    exit 0
                  fi
                  echo "Attempt $i: HTTP $STATUS — retrying in 10s..."
                  sleep 10
                done
                echo "Health check FAILED after 6 attempts"
                exit 1

# ──────────────────────────────────────────────────────────────────────────────
# Stage 3: Deploy UAT (manual approval gate, slot swap)
# ──────────────────────────────────────────────────────────────────────────────
- stage: DeployUAT
  displayName: 'Deploy to UAT'
  dependsOn: DeployDev
  condition: succeeded()
  variables:
  - group: re2-uat-secrets
  jobs:
  - deployment: DeployUATInfra
    displayName: 'Deploy infrastructure'
    environment: 're2-uat'   # Manual approval gate configured on this environment
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Create resource group'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az group create \
                  --name rg-re2-uat \
                  --location westeurope \
                  --tags environment=uat application=re2-compliance

          - task: AzureCLI@2
            displayName: 'Deploy Bicep templates'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az deployment group create \
                  --resource-group rg-re2-uat \
                  --template-file $(Pipeline.Workspace)/drop/infra/main.bicep \
                  --parameters $(Pipeline.Workspace)/drop/infra/uat.bicepparam \
                  --parameters azureAdTenantId=$(AzureAdTenantId) \
                               azureAdClientId=$(AzureAdClientId) \
                  --verbose

  - deployment: DeployUATApps
    displayName: 'Deploy applications (slot swap)'
    dependsOn: DeployUATInfra
    environment: 're2-uat'
    strategy:
      runOnce:
        deploy:
          steps:
          # Deploy API to staging slot
          - task: AzureWebApp@1
            displayName: 'Deploy API to staging slot'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              appType: 'webApp'
              appName: 'app-re2-api-uat'
              deployToSlotOrASE: true
              slotName: 'staging'
              package: '$(Pipeline.Workspace)/drop/api/**/*.zip'

          # Deploy Web to staging slot
          - task: AzureWebApp@1
            displayName: 'Deploy Web to staging slot'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              appType: 'webApp'
              appName: 'app-re2-web-uat'
              deployToSlotOrASE: true
              slotName: 'staging'
              package: '$(Pipeline.Workspace)/drop/web/**/*.zip'

          # Deploy Functions directly (no slot swap for consumption plan)
          - task: AzureFunctionApp@2
            displayName: 'Deploy Functions'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              appType: 'functionApp'
              appName: 'func-re2-compliance-uat'
              package: '$(Pipeline.Workspace)/drop/functions/**/*.zip'

          # Smoke test staging slots
          - task: AzureCLI@2
            displayName: 'Smoke test — API staging slot'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                API_URL="https://app-re2-api-uat-staging.azurewebsites.net/health"
                echo "Testing $API_URL"
                for i in {1..6}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL" --max-time 10)
                  if [ "$STATUS" = "200" ]; then
                    echo "Staging health check passed (HTTP 200)"
                    exit 0
                  fi
                  echo "Attempt $i: HTTP $STATUS — retrying in 10s..."
                  sleep 10
                done
                echo "Staging health check FAILED"
                exit 1

          - task: AzureCLI@2
            displayName: 'Smoke test — Web staging slot'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                WEB_URL="https://app-re2-web-uat-staging.azurewebsites.net/health"
                echo "Testing $WEB_URL"
                for i in {1..6}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$WEB_URL" --max-time 10)
                  if [ "$STATUS" = "200" ]; then
                    echo "Staging health check passed (HTTP 200)"
                    exit 0
                  fi
                  echo "Attempt $i: HTTP $STATUS — retrying in 10s..."
                  sleep 10
                done
                echo "Staging health check FAILED"
                exit 1

          # Swap staging → production (zero-downtime)
          - task: AzureAppServiceManage@0
            displayName: 'Swap API: staging → production'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              action: 'Swap Slots'
              webAppName: 'app-re2-api-uat'
              resourceGroupName: 'rg-re2-uat'
              sourceSlot: 'staging'

          - task: AzureAppServiceManage@0
            displayName: 'Swap Web: staging → production'
            inputs:
              azureSubscription: 'RE2-UAT-ServiceConnection'
              action: 'Swap Slots'
              webAppName: 'app-re2-web-uat'
              resourceGroupName: 'rg-re2-uat'
              sourceSlot: 'staging'

# ──────────────────────────────────────────────────────────────────────────────
# Stage 4: Deploy Prod (manual approval gate — 2 approvers, slot swap)
# ──────────────────────────────────────────────────────────────────────────────
- stage: DeployProd
  displayName: 'Deploy to Prod'
  dependsOn: DeployUAT
  condition: succeeded()
  variables:
  - group: re2-prod-secrets
  jobs:
  - deployment: DeployProdInfra
    displayName: 'Deploy infrastructure'
    environment: 're2-prod'   # Manual approval gate — 2 approvers required
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Create resource group'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az group create \
                  --name rg-re2-prod \
                  --location westeurope \
                  --tags environment=prod application=re2-compliance

          - task: AzureCLI@2
            displayName: 'Deploy Bicep templates'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az deployment group create \
                  --resource-group rg-re2-prod \
                  --template-file $(Pipeline.Workspace)/drop/infra/main.bicep \
                  --parameters $(Pipeline.Workspace)/drop/infra/prod.bicepparam \
                  --parameters azureAdTenantId=$(AzureAdTenantId) \
                               azureAdClientId=$(AzureAdClientId) \
                  --verbose

  - deployment: DeployProdApps
    displayName: 'Deploy applications (slot swap)'
    dependsOn: DeployProdInfra
    environment: 're2-prod'
    strategy:
      runOnce:
        deploy:
          steps:
          # Deploy API to staging slot
          - task: AzureWebApp@1
            displayName: 'Deploy API to staging slot'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              appType: 'webApp'
              appName: 'app-re2-api-prod'
              deployToSlotOrASE: true
              slotName: 'staging'
              package: '$(Pipeline.Workspace)/drop/api/**/*.zip'

          # Deploy Web to staging slot
          - task: AzureWebApp@1
            displayName: 'Deploy Web to staging slot'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              appType: 'webApp'
              appName: 'app-re2-web-prod'
              deployToSlotOrASE: true
              slotName: 'staging'
              package: '$(Pipeline.Workspace)/drop/web/**/*.zip'

          # Deploy Functions directly (Elastic Premium — could use slots, but keeping simple)
          - task: AzureFunctionApp@2
            displayName: 'Deploy Functions'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              appType: 'functionApp'
              appName: 'func-re2-compliance-prod'
              package: '$(Pipeline.Workspace)/drop/functions/**/*.zip'

          # Smoke test staging slots
          - task: AzureCLI@2
            displayName: 'Smoke test — API staging slot'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                API_URL="https://app-re2-api-prod-staging.azurewebsites.net/health"
                echo "Testing $API_URL"
                for i in {1..6}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL" --max-time 10)
                  if [ "$STATUS" = "200" ]; then
                    echo "Staging health check passed (HTTP 200)"
                    exit 0
                  fi
                  echo "Attempt $i: HTTP $STATUS — retrying in 10s..."
                  sleep 10
                done
                echo "Staging health check FAILED"
                exit 1

          - task: AzureCLI@2
            displayName: 'Smoke test — Web staging slot'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                WEB_URL="https://app-re2-web-prod-staging.azurewebsites.net/health"
                echo "Testing $WEB_URL"
                for i in {1..6}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$WEB_URL" --max-time 10)
                  if [ "$STATUS" = "200" ]; then
                    echo "Staging health check passed (HTTP 200)"
                    exit 0
                  fi
                  echo "Attempt $i: HTTP $STATUS — retrying in 10s..."
                  sleep 10
                done
                echo "Staging health check FAILED"
                exit 1

          # Swap staging → production (zero-downtime)
          - task: AzureAppServiceManage@0
            displayName: 'Swap API: staging → production'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              action: 'Swap Slots'
              webAppName: 'app-re2-api-prod'
              resourceGroupName: 'rg-re2-prod'
              sourceSlot: 'staging'

          - task: AzureAppServiceManage@0
            displayName: 'Swap Web: staging → production'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              action: 'Swap Slots'
              webAppName: 'app-re2-web-prod'
              resourceGroupName: 'rg-re2-prod'
              sourceSlot: 'staging'

          # Post-deployment verification
          - task: AzureCLI@2
            displayName: 'Post-swap — verify production health'
            inputs:
              azureSubscription: 'RE2-Prod-ServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== Verifying production endpoints ==="
                for APP in "app-re2-api-prod" "app-re2-web-prod"; do
                  URL="https://${APP}.azurewebsites.net/health"
                  echo "Testing $URL"
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL" --max-time 10)
                  if [ "$STATUS" != "200" ]; then
                    echo "WARNING: $URL returned HTTP $STATUS after swap"
                  else
                    echo "OK: $URL returned HTTP 200"
                  fi
                done
